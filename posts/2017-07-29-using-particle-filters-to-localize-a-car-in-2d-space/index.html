<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Using Particle Filters to localize a car in 2D space - boxmein</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This is a discussion on how I implemented and finished the Particle Filters project in the Udacity Self-Driving Car Engineer Nanodegree.
The challenge Given a map of the world (a bunch of landmarks), and the car drawing lines to all landmarks within range with noisy data, give the best assumption for the car&rsquo;s position in the world.
The process How I was going to solve it was with an approach called particle filters."><meta property="og:image" content><meta property="og:title" content="Using Particle Filters to localize a car in 2D space"><meta property="og:description" content="This is a discussion on how I implemented and finished the Particle Filters project in the Udacity Self-Driving Car Engineer Nanodegree.
The challenge Given a map of the world (a bunch of landmarks), and the car drawing lines to all landmarks within range with noisy data, give the best assumption for the car&rsquo;s position in the world.
The process How I was going to solve it was with an approach called particle filters."><meta property="og:type" content="article"><meta property="og:url" content="https://boxmein.github.io/posts/2017-07-29-using-particle-filters-to-localize-a-car-in-2d-space/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-07-29T00:00:00+00:00"><meta property="article:modified_time" content="2017-07-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Particle Filters to localize a car in 2D space"><meta name=twitter:description content="This is a discussion on how I implemented and finished the Particle Filters project in the Udacity Self-Driving Car Engineer Nanodegree.
The challenge Given a map of the world (a bunch of landmarks), and the car drawing lines to all landmarks within range with noisy data, give the best assumption for the car&rsquo;s position in the world.
The process How I was going to solve it was with an approach called particle filters."><link href=https://boxmein.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://boxmein.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css><script src=https://boxmein.github.io/posthog-tag.js></script></head><body><div class=content><header><div class=main><a href=https://boxmein.github.io/>boxmein</a></div><nav></nav></header><main><article><div class=title><h1 class=title>Using Particle Filters to localize a car in 2D space</h1><div class=meta>Posted on Jul 29, 2017</div></div><section class=body><p>This is a discussion on how I implemented and finished the Particle Filters project in the Udacity Self-Driving Car Engineer Nanodegree.</p><h3 id=the-challenge>The challenge</h3><p>Given a map of the world (a bunch of landmarks), and the car drawing lines to all landmarks within range with noisy data, give the best assumption for the car&rsquo;s position in the world.</p><h3 id=the-process>The process</h3><p>How I was going to solve it was with an approach called <strong>particle filters</strong>. It essentially throws many &ldquo;cars&rdquo; into the world, and sees which fit the landmark measurements the best, eliminating the worst &ldquo;cars&rdquo; by weighted sampling.</p><p>We assume the car moves like a <strong>bicycle</strong>:</p><ul><li>The two front wheels move and rotate as one</li><li>The two back wheels move as one</li><li>The front and back wheels are constantly distanced from each other.</li><li>This means we are using a <strong>constant turn rate & velocity</strong> model - CTRV for short.</li><li>Note that in the real world, cars don&rsquo;t have constant turn rate and velocity, but we can correct the particle&rsquo;s velocity and turn rate as we go along. In the span of ~10 ms, we can assume the model to be close enough to the real world.</li></ul><p>This will help us in the future, making the particles follow the car.</p><p>We use the Udacity Term-2 Simulator to provide us with car sensor data, and load a world map from a file.</p><p>Here&rsquo;s what our program will look like as a flowchart. Various data / information used in each step are shown in blue. Places where we have to manually introduce noise into our model to account for an uncertain representation are shown in blue.</p><p><img src=images/screen-shot-2017-07-29-at-20-44-20.png alt="Screen Shot 2017-07-29 at 20.44.20"></p><h3 id=initialization>Initialization</h3><p>In initialization, we have to create many particles that are, in essence, random guesses to where the car may be and what way it is heading. However, to start off, we can use a coarse estimate such as a GPS reading to place our particles more efficiently.</p><p>We initialize a set of 80 particles, each with a randomly drawn X, Y and angle, from a multivariate normal distribution centered on the GPS reading and with a standard deviation of 5 meters.</p><h3 id=prediction>Prediction</h3><p>In the prediction step, we move all particles according to how the car moved. What we know from the car&rsquo;s internal metrics is the velocity, delta-time, and the yaw rate, so we have to use our motion model to find new X/Y positions and heading for every particle.</p><p>Here we also add some random noise to each value, because the velocity & yaw rate sensors may not be too accurate. More precisely, we know upfront what noise values we should use for the X, Y and yaw values.</p><p>Here&rsquo;s the equations I used to implement the bicycle motion model:</p><p><img src=images/screen-shot-2017-07-29-at-20-51-00.png alt="Screen Shot 2017-07-29 at 20.51.00"></p><p>where xf, yf and theta-f are the posterior X, Y and yaw values, in m, x0, y0 and theta-0 are the prior X, Y and yaw values, in m, v is the velocity of the car, in m/s, theta-dot is the yaw rate of the car, in rad/s^2, and dt is the delta-time in seconds.</p><h3 id=update>Update</h3><p>In the update step, we weigh all particles by how accurately they match the measurements.</p><p>For this, we first take all the car&rsquo;s measurements (in relative coordinates - where the car is the origin, the X axis points toward the front, and the Y axis toward the left), and translate them to global coordinates. This is achieved by essentially translating and rotating a vector. You will be able to find an equation <a href=https://www.willamette.edu/~gorr/classes/GeneralGraphics/Transforms/transforms2d.htm>online</a> for that.</p><p>After that, we find all landmarks that are in sensor range of the particle - simply find the distance between the particle and each landmark and threshold by sensor range. This gives us a list of <em>predicted</em> landmarks. (Since we are trying to predict which landmarks the car sees)</p><p>Thirdly, for each measurement, we find the nearest <em>predicted</em> landmark to each translated measurement <em>(observation).</em> This is a simple minimum distance algorithm (nearest neighbor). We keep track of each measurement&rsquo;s nearest landmark.</p><p><strong>Note to self:</strong> in this project, each landmark is indexed starting from 1, but are loaded into an array starting from 0. This means <strong>the landmark with the ID 1 will be in the landmark list at position 0.</strong></p><p>Fourth, we will find the distance between each measurement and landmark, and find the multivariate Gaussian distribution value according to those distances. Each measurement&rsquo;s weights will be multiplied together and the resulting weight will be the particle&rsquo;s weight. (The bigger the weight, the more accurate this particle is)</p><p>Here&rsquo;s the reduced-case algorithm that gives us the weight of one measurement, assuming a few things:</p><ul><li>A two-dimensional world (x, y)</li><li>A uniform <strong>non-correlated noise</strong> for x and y measurements</li></ul><p><img src=images/screen-shot-2017-07-29-at-21-00-50.png alt="Screen Shot 2017-07-29 at 21.00.50.png"></p><p>where x, y are the landmark&rsquo;s global coordinates in m, µx and µy are the measurement&rsquo;s global coordinates in m, and σx and σy are the measurement&rsquo;s x and y standard deviations in m.</p><p>Reinitialize a particle&rsquo;s weight to 1, and for each measurement, simply multiply the value of the equation above onto the particle&rsquo;s weight.</p><p>After the update, we will collect all the particles&rsquo; weights into a vector for the resampling step.</p><h4 id=bonus-step---particle-associations--blue-rays>Bonus Step - Particle Associations & Blue Rays</h4><p>The Udacity Simulator supports an extra set of data - each particle&rsquo;s transformed measurement list. If you enable this, you will get fancy blue rays pointing to your best particle&rsquo;s observations.</p><p>To implement this:</p><ol><li>For each measurement/<em>observation</em> in the translated vector of measurements (in global coordinates for this particle):</li><li>Add the measurement&rsquo;s ID to the particle.associations vector</li><li>Add the measurement&rsquo;s X to the particle.sense_x vector</li><li>Add the measurement&rsquo;s Y to the particle.sense_y vector</li></ol><h3 id=resampling>Resampling</h3><p>After we know each particle&rsquo;s weight, we have to redraw a new set of particles. In this step, it is expected that multiple copies of one particle will survive in the new set.</p><p>The simplest way to do it is to use the C++ builtin std::discrete_distribution. To create it, pass it an array of weights (in vector form). It will then return integers from 0 to the length of the array according to their weights. This is ideal in our case, since we need indices to pick particles from our existing array.</p><p>std::discrete_distribution particleDist(weights.begin(), weights.end());</p><p>After the resampling is done, we will have a new list of particles where there&rsquo;s proportionally more particles with a higher weight, and some very low-weighted particles may even disappear.</p><p><strong>Note to self: the discrete_distribution constructor doesn&rsquo;t take vectors, but it takes start and end iterators, which are easy to get from a vector.</strong></p><p>After the resample step, the code will go back to the prediction step. This is it!</p><h3 id=conclusion>Conclusion</h3><p>This project was a lot of fun, and easy to implement. I spent around ~10 hours on it, plus a few lost strands of hair.</p><p>What made the project hard for me is the fact that the simulator only shows the best particle, so if your weighting function is buggy and causing all particles to have zero weight, it always shows the first.</p><p>Additionally, I didn&rsquo;t know how to implement the sense/association data and I had to figure it out manually.</p><p>Lastly, the errors I had were caused by a simple off-by-one error. The landmark id-s start from 1, but I was using the landmark id-s to index the landmarks array, sometimes causing segfaults and most of the time causing the car to veer off tremendously.</p><p>A judicious use of the LLDB debugger, and verbose logging helped me a lot to find those last few bugs.</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/localization>localization</a></li><li><a href=/tags/term-2>term-2</a></li></ul></nav></div></article></main><footer><div style=display:flex></div><div class=footer-info>2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>