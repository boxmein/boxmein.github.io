<!DOCTYPE html><html><head><link rel="stylesheet" href="index.css"><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" href="github.css"></head><body><h1>inmake</h1><ul id="navigation"><li><a href="#about">About</a></li><li><a href="#usage">Usage</a></li><li><a href="https://gist.github.com/boxmein/8303778/download">Download</a></li><li><a href="#source-code">Source code</a></li><li><a href="#sublime">Sublime build script</a></li><li><a href="#examples">Examples</a></li></ul><div id="text"><h1 id="about">About</h1>
<p>I wrote this because I didn&#39;t like having to remember the build command for
every source file I wrote. Then I kind of made it into a Sublime plugin to beat 
all Sublime plugins. ...and then into an entire command-line tool.</p>
<h1 id="usage">Usage</h1>
<p>There&#39;s, like, 4 ways of using this tool.</p>
<h3 id="like-a-shebang-line">Like a shebang line</h3>
<p>You know how your python scripts already have two copy/pasted lines at the start of each script that go like <code>#!/usr/bin/python</code> and <code># -*- encoding: utf-8 -*-</code>? Well, why not add another one! The third (or second) line can now be used as a command prefix! Prepend some amount of non-whitespace characters to mark it off as a comment and this script will cut it right off. An example Python script would look like that one down there:</p>
<pre><code class="lang-python">#!/usr/bin/python3
# -*- encoding: utf-8
# weird-python-compiler pythonfile.py -o out.html
</code></pre>
<h3 id="command-prefix">Command prefix</h3>
<p>You can also manually say what kind of prefix the command has, so the script will find the line for you. Once it&#39;s found the prefix is snipped from the start and the results run via <code>system</code>.</p>
<pre><code class="lang-ruby">rx = /^\s*#{options[:prefix]}\s*/
command = f.each_line.detect do |line|
  rx.match line
end
abort &quot;No line with that prefix!&quot; unless command
command.gsub!(rx, &#39;&#39;)
</code></pre>
<p>That&#39;s all it takes to implement! You can put it to good use with a comment like</p>
<pre><code class="lang-c">//# gcc -o test test.c
</code></pre>
<p>... coupled with the command</p>
<pre><code class="lang-bash">ruby inmake.rb -f test.c -p &quot;//#&quot;
</code></pre>
<h3 id="command-suffix-postfix-">Command suffix (postfix)</h3>
<p>You can also specify a postfix that you can append to the end of the line, also searched for and snipped like the prefix. </p>
<p>In this case however, the program also walks right until the first whitespace character to cut off any comment characters you might&#39;ve stashed there. Useful to leave impromptuwhitespacelessnotes.</p>
<pre><code class="lang-ruby">rx = /#{opts[:postfix]}\s*$/
command = f.each_line.detect do |line|
  rx.match line
end
abort &quot;No line with that postfix!&quot; unless command
command.gsub!(rx, &#39;&#39;)
command = command[(command =~ /\s/)...command.length].strip
</code></pre>
<p>This also looks simple, because it is. You can employ it with comments such as </p>
<pre><code class="lang-c">//remembertogetsomemilkfromthestore gcc -o test test.c moo
</code></pre>
<p>... eternally bound to the command</p>
<pre><code class="lang-bash">ruby inmake.rb -f test.c -m moo
</code></pre>
<h3 id="regexing">Regexing</h3>
<p>For the extremely brave and the unwieldily apt, there&#39;s also a way to specify your own regular expression! It&#39;s got to be of a flavor Ruby supports, which means it&#39;s 99% certainly Perl-compatible regex. Also, skip the surrounding slashes, we&#39;ve got enough of them inside the code anyway. Thing is, there&#39;s no way <em>yet</em> to set any flags for the regex, so you&#39;ll get none.</p>
<pre><code class="lang-ruby">rx = opts[:regex]
command = f.each_line.detect do |line|
rx.match line
end
abort &quot;Regex didn&#39;t match any lines!&quot; unless command
command = command[(command =~ /\s/)...command.length].strip
command.gsub!(rx, &#39;&#39;) if opts[:sm]
</code></pre>
<p>Okay so as you see there&#39;s a regex option, but what&#39;s that <code>:sm</code> option? 
That&#39;s to tell the script to cut your newly-matched snippets off as well as finding them. You can set that flag on the command line with the <code>--strip-matched</code> option.</p>
<p>Use regexes with any type of comment you can match to (for example:</p>
<pre><code class="lang-c">// g~c~c -~o t~e~s~t t~e~s~t~.~c -DAWESOME=~1
</code></pre>
<p>) and matching with: </p>
<pre><code class="lang-bash">ruby inmake.rb -f test.c -r &quot;~&quot; --strip-matched
</code></pre>
<p>The stripping will always substitute every match on the line, since <code>String#gsub!</code> is used for the process.</p>
<p><a name="sublime"></a></p>
<h1 id="sublime-text-build-script">Sublime Text build script</h1>
<p>This tool is an awesome companion to your text editor. I use Sublime Text, so 
I&#39;ve also included the build script I use here. Make sure to replace $LOCATION
with where your script resides in.</p>
<pre><code class="lang-json">{
  &quot;shell_cmd&quot;: &quot;ruby $LOCATION/inmake.rb -f \&quot;$file\&quot;&quot;
}
</code></pre>
<h1 id="source-code">Source code</h1>
<p>The source code will always just be accessible <a href="https://gist.github.com/boxmein/8303778">here</a>. </p>
<h1 id="examples">Examples</h1>
<p>The simplest way to use inmake is to not specify any other flags and let it use
line 2 of the source code as your shell command. For example, </p>
<pre><code class="lang-c">// A simple hello-world script.
// gcc -o test test.c -DAWESOME=1
// (ruby inmake.rb -f test.c)
#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Hello world!\n&quot;);

    if (AWESOME){
        printf(&quot;awesome!\n&quot;);
    }
}
</code></pre>
<p>You can use the post-fix mode like this:</p>
<pre><code class="lang-c">// gcc -o test test.c -DAWESOME=1 thisisapostfix
// (ruby inmake.rb -f test.c -m &#39;thisisapostfix&#39;)
#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Hello world!\n&quot;);

    if (AWESOME){
        printf(&quot;awesome!\n&quot;);
    }
}
</code></pre>
<p>And you can use the regex mode like this: </p>
<pre><code class="lang-c">// !!!!! gcc -o test test.c -DAWESOME=1 !!!!!
// (ruby inmake.rb -f test.c -r &#39;^!!!!!|!!!!!$&#39; --strip-matched)
int main() {
    printf(&quot;Hello world!\n&quot;);
    if (AWESOME){
        printf(&quot;awesome!\n&quot;);
    }
}
</code></pre>
<p>..This pretty much covers examples.</p>
</div><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><div id="afterspace"></div></body></html>